{"mappings":";;;;;;;;ACEO,MAAM,4CACX,CAAW,WACX,CAAC,iBACC,SAAS,MAAM,CAAC,CAAC,KAAK,MAAQ,CAAC,KAAK,MAAQ,IAAI,KAAK,KAAK,IAAM,IAAI,KAAK,OAAO;;ADLpF;;;;;;AEAA;;;;;;ACAO,MAAM,4CAA4B;AAElC,MAAM,4CAAwB;AAC9B,MAAM,4CAA8B;;;ACH3C;AAEO,MAAM,4CAAsB,CAAC,OAAgB,iBAAoC;IACtF,IAAI,OAAO,UAAU,UAAU,OAAO;IACtC,IAAI,iBAAiB,OAAO,OAAO,MAAM,OAAO;IAChD,OAAO,2BAAA,4BAAA,iBAAkB,CAAA,GAAA,yCAAwB,CAAC;AACpD;;;AFEO,MAAM,4CACX,CAAC;IACD,OAAA,OAAO,KAAK,KAAK,OAAS;QACxB,MAAM,gBAAE,eAAe,CAAA,GAAA,yCAAwB,kBAAG,aAAY,EAAE,GAAG,QAAQ,CAAC;QAC5E,IAAI;YACF,OAAM,iBAAA,kBAAA,KAAA,IAAA,KAAO,KAAK,KAAK;QACzB,EAAE,OAAO,OAAO;YACd,MAAM,eAAe,IAAI,UAAU,KAAK;YACxC,MAAM,SAAS,eAAe,MAAM,IAAI,UAAU,IAAI,GAAG;YAEzD,IAAI,iBAAiB,OAAO;gBAC1B,yBAAA,0BAAA,KAAA,IAAA,aAAc,KAAK,CAAC,CAAA,GAAA,yCAAkB,EAAE,OAAO;gBAC/C,IAAI,MAAM,CAAC,QAAQ,IAAI,CAAC;oBAAE,SAAS,CAAA,GAAA,yCAAmB,AAAD,EAAE,OAAO;gBAAc;YAC9E,OACE,IAAI,MAAM,CAAC,QAAQ,IAAI,CAAC;gBAAE,SAAS;YAAa;QAEpD;IACF;;AAEK,MAAM,4CACX,CAAC;IACD,OAAA,OAAO,KAAK,KAAK,OAAS;QACxB,MAAM,WAAE,UAAU,CAAA,GAAA,yCAAoB,kBAAG,eAAe,CAAA,GAAA,yCAA2B,AAAD,IAAG,GAAG,QAAQ,CAAC;QACjG,IAAI;YACF,IAAI,SAAS,CAAC,iBAAiB;YAE/B,OAAM,iBAAA,kBAAA,KAAA,IAAA,KAAO,KAAK,KAAK;QACzB,EAAE,OAAO,OAAO;YACd,0CAA0C;YAC1C,sDAAsD;YACtD,IAAI,SAAS,CAAC,iBAAiB;YAE/B,2BAA2B;YAC3B,MAAM,MAAK;QACb;IACF;;AAEK,MAAM,4CACX,CAAC,SAA4B;IAC7B,OAAA,OAAO,KAAK,KAAK,OAAS;QACxB,IAAI,SAAS;QACb,MAAM,YAAY,QAAQ,UAAU,CAAC;mBAAE;QAAM;QAE7C,IAAI;YACF,OAAM,iBAAA,kBAAA,KAAA,IAAA,KAAO,KAAK,KAAK;YACvB,SAAS,CAAA,GAAA,qBAAc,AAAD,EAAE,IAAI,UAAU;QACxC,EAAE,OAAO,OAAO;YACd,SAAS,CAAA,GAAA,qBAAc,AAAD,EAAE,IAAI,UAAU;YACtC,2BAA2B;YAC3B,MAAM,MAAK;QACb,SAAU;YACR,UAAU;wBAAE;YAAO;QACrB;IACF;;;;;;;","sources":["packages/next/api-wrapper/src/index.ts","packages/next/api-wrapper/src/wrapRequest.ts","packages/next/api-wrapper/src/wrappers.ts","packages/next/api-wrapper/src/constants.ts","packages/next/api-wrapper/src/utils.ts","packages/next/api-wrapper/src/types.ts"],"sourcesContent":["export * from './wrapRequest'\nexport * from './wrappers'\nexport * from './constants'\nexport * from './types'\n","import { RequestWrapper, API } from './types'\n\nexport const wrapRequest =\n  <T = void>(wrappers: RequestWrapper<T>[]) =>\n  (requestHandler: API<T>) =>\n    wrappers.reduce((acc, cur) => (req, res) => cur(req, res, () => acc(req, res)), requestHandler)\n","import { Histogram } from 'prom-client'\nimport { getStatusLabel } from '@lidofinance/api-metrics'\n\nimport { DEFAULT_API_ERROR_MESSAGE, CACHE_DEFAULT_ERROR_HEADERS, CACHE_DEFAULT_HEADERS } from './constants'\nimport { extractErrorMessage } from './utils'\nimport { RequestWrapper, DefaultErrorHandlerArgs, CacheControlArgs } from './types'\n\n// must be last in the wrapper stack\nexport const defaultErrorHandler =\n  (args?: DefaultErrorHandlerArgs): RequestWrapper =>\n  async (req, res, next) => {\n    const { errorMessage = DEFAULT_API_ERROR_MESSAGE, serverLogger } = args || {}\n    try {\n      await next?.(req, res, next)\n    } catch (error) {\n      const isInnerError = res.statusCode === 200\n      const status = isInnerError ? 500 : res.statusCode || 500\n\n      if (error instanceof Error) {\n        serverLogger?.error(extractErrorMessage(error, errorMessage))\n        res.status(status).json({ message: extractErrorMessage(error, errorMessage) })\n      } else {\n        res.status(status).json({ message: errorMessage })\n      }\n    }\n  }\n\nexport const cacheControl =\n  (args?: CacheControlArgs): RequestWrapper =>\n  async (req, res, next) => {\n    const { headers = CACHE_DEFAULT_HEADERS, errorHeaders = CACHE_DEFAULT_ERROR_HEADERS } = args || {}\n    try {\n      res.setHeader('Cache-Control', headers)\n\n      await next?.(req, res, next)\n    } catch (error) {\n      // for requests with cache-control headers\n      // need set new headers otherwise error will be cached\n      res.setHeader('Cache-Control', errorHeaders)\n\n      // throw error up the stack\n      throw error\n    }\n  }\n\nexport const responseTimeMetric =\n  (metrics: Histogram<string>, route: string): RequestWrapper =>\n  async (req, res, next) => {\n    let status = '2xx'\n    const endMetric = metrics.startTimer({ route })\n\n    try {\n      await next?.(req, res, next)\n      status = getStatusLabel(res.statusCode)\n    } catch (error) {\n      status = getStatusLabel(res.statusCode)\n      // throw error up the stack\n      throw error\n    } finally {\n      endMetric({ status })\n    }\n  }\n","export const DEFAULT_API_ERROR_MESSAGE = 'Something went wrong.'\n\nexport const CACHE_DEFAULT_HEADERS = 'public, max-age=180, stale-if-error=1200, stale-while-revalidate=60'\nexport const CACHE_DEFAULT_ERROR_HEADERS = 'no-store, must-revalidate'\n","import { DEFAULT_API_ERROR_MESSAGE } from './constants'\n\nexport const extractErrorMessage = (error: unknown, defaultMessage?: string): string => {\n  if (typeof error === 'string') return error\n  if (error instanceof Error) return error.message\n  return defaultMessage ?? DEFAULT_API_ERROR_MESSAGE\n}\n","import { NextApiResponse, NextApiRequest } from 'next'\nimport { ServerLogger } from '@lidofinance/api-logger'\n\nexport type API<T = void> = (req: NextApiRequest, res: NextApiResponse) => Promise<T> | T\n\nexport type RequestWrapper<T = void> = (\n  req: NextApiRequest,\n  res: NextApiResponse,\n  next?: API<T> | RequestWrapper<T>,\n) => Promise<T> | T\n\nexport type MixedWrapper = <T = void>(api: API<T>) => RequestWrapper<T>\n\nexport type DefaultErrorHandlerArgs = {\n  errorMessage?: string\n  serverLogger?: ServerLogger\n}\n\nexport type CacheControlArgs = {\n  headers?: string\n  errorHeaders?: string\n}\n"],"names":[],"version":3,"file":"index.mjs.map"}