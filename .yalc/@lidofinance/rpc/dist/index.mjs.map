{"mappings":";;;;;;;;;ACoBO,MAAM,4CAAqB,CAAC,KAAK,OACtC,MAAM,KAAK;QACT,GAAG,IAAI;QACP,QAAQ;QACR,SAAS;YACP,GAAG,KAAK,OAAO;YACf,gBAAgB;QAClB;QACA,MAAM,KAAK,UAAU,KAAK;IAC5B;;;;;;;AC7BK,MAAM,kDAAgC;IAC3C,YAAY,OAAgB,CAAE;QAC5B,KAAK,CAAC,WAAW;IACnB;AACF;AAEO,MAAM,4CAAc,OACzB,MACA,UACA;IAEA,IAAI;IACJ,IAAI;IAEJ,KAAK,MAAM,OAAO,KAChB,IAAI;QACF,MAAM,WAAW,MAAM,SAAS;QAChC,eAAe;QAEf,6CAA6C;QAC7C,IAAI,OAAO,aAAa,eAAe,oBAAoB,YAAY,CAAC,SAAS,IAC/E;QAGF,OAAO;IACT,EAAE,OAAO,OAAO;QACd,UAAU;QACV,YAAY;IACd;IAGF,8DAA8D;IAC9D,IAAI,gBAAgB,MAClB,OAAO;IAET,qDAAqD;IACrD,IAAI,aAAa,MACf,MAAM;IAER,+BAA+B;IAC/B,MAAM,IAAI;AACZ;;","sources":["packages/core/rpc/src/index.ts","packages/core/rpc/src/fetchRpc.ts","packages/core/rpc/src/iterateUrls.ts"],"sourcesContent":["import 'isomorphic-fetch'\n\nexport * from './fetchRpc'\nexport * from './iterateUrls'\n","export type FetchRpcInitBody = {\n  jsonrpc: '1.0' | '2.0' | string\n  method: string\n  params?: unknown\n  id?: string | number | null\n}\n\n// eslint-disable-next-line no-undef\nexport type FetchRpcInit = Omit<RequestInit, 'body' | 'method'> & {\n  method?: 'POST'\n  body: FetchRpcInitBody | FetchRpcInitBody[]\n}\n\n// Need Extension type so we can extend fetchRPC with metrics tracking or caching\nexport type FetchRpc<Extension extends Record<string | number, unknown> | void = void> = (\n  url: string,\n  init: FetchRpcInit,\n  extension: Extension,\n) => Promise<Response>\n\nexport const fetchRpc: FetchRpc = (url, init) =>\n  fetch(url, {\n    ...init,\n    method: 'POST',\n    headers: {\n      ...init.headers,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(init.body),\n  })\n","export class ExhaustedIterationError extends Error {\n  constructor(message?: string) {\n    super(message ?? 'Iteration ended without success')\n  }\n}\n\nexport const iterateUrls = async <T>(\n  urls: [string, ...string[]],\n  callback: (url: string) => T | Promise<T>,\n  onError?: (error: unknown) => unknown,\n): Promise<T> => {\n  let lastResponse: T | undefined\n  let lastError: unknown | undefined\n\n  for (const url of urls) {\n    try {\n      const response = await callback(url)\n      lastResponse = response\n\n      // We want to return first succeeded response\n      if (typeof Response !== 'undefined' && response instanceof Response && !response.ok) {\n        continue\n      }\n\n      return response\n    } catch (error) {\n      onError?.(error)\n      lastError = error\n    }\n  }\n\n  // If there are no succeeded responses, return last not thrown\n  if (lastResponse != null) {\n    return lastResponse\n  }\n  // If there are no responses at all, throw last error\n  if (lastError != null) {\n    throw lastError\n  }\n  // This should not be reachable\n  throw new ExhaustedIterationError()\n}\n"],"names":[],"version":3,"file":"index.mjs.map"}